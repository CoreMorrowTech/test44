# JavaScript异步线程管理使用指南

## 概述

JavaScript异步线程管理功能为设备控制界面提供了完整的异步命令管理能力，解决了异步命令和同步命令之间的资源冲突问题。

## 主要功能

### 1. 可视化管理面板

设备控制界面中集成了异步线程管理面板，提供：

- **实时状态显示**：显示当前运行的异步命令数量和名称
- **停止所有异步命令**：一键停止所有正在运行的异步命令
- **刷新状态**：手动刷新异步命令状态
- **确保同步执行**：清理异步命令，确保同步命令可以安全执行

### 2. 核心API功能

#### 状态查询
```javascript
// 检查指定异步命令是否在运行
const isRunning = connectionInstance.isAsyncCommandRunning("getxChannelVoltageTms");

// 获取所有运行中的异步命令
const runningCommands = connectionInstance.getRunningAsyncCommands();

// 获取整体状态信息
const status = connectionInstance.getAsyncStatus();
console.log(`运行中的命令: ${status.running_commands}`);
console.log(`命令数量: ${status.count}`);
```

#### 异步命令控制
```javascript
// 停止指定的异步命令
const success = connectionInstance.stopAsyncCommand("getxChannelVoltageTms");

// 停止所有异步命令
connectionInstance.stopAllAsyncCommands();

// 等待异步命令完成（最多等待5秒）
const completed = connectionInstance.waitForAsyncCommand("getxChannelVoltageTms", 5000);
```

#### 安全执行同步命令
```javascript
// 方法1: 自动清理所有异步命令
if (connectionInstance.ensureSyncExecution()) {
    // 现在可以安全执行同步命令
    const result = connectionInstance.executeCommandJSON("getAddress", []);
}

// 方法2: 只清理特定的异步命令
if (connectionInstance.ensureSyncExecution("getxChannelVoltageTms")) {
    // 只停止了指定的异步命令
    const result = connectionInstance.executeCommandJSON("someOtherCommand", []);
}
```

### 3. 界面集成功能

#### 自动异步命令检测
设备控制界面会自动检测异步命令（`timeout=-1` 或 `asyncMode=true`），并：

- 防止重复启动同名异步命令
- 提供用户确认机制
- 可视化显示异步命令状态
- 自动记录和跟踪异步命令

#### 智能冲突处理
```javascript
// 当用户尝试启动已运行的异步命令时
if (isAsyncCommandRunning(commandName)) {
    const shouldStop = confirm(`异步命令 '${commandName}' 已在运行，是否停止旧命令并启动新命令？`);
    if (shouldStop) {
        stopAsyncCommand(commandName);
        // 等待停止完成后启动新命令
        setTimeout(() => {
            executeAsyncCommand(commandName, params, command, channel);
        }, 200);
    }
}
```

## 使用场景

### 场景1: 异步监控 + 同步控制

```javascript
// 1. 启动异步电压监控
const asyncResult = connectionInstance.executeCommandJSON("getxChannelVoltageTms", [1, 1, 100]);
console.log("异步监控已启动:", asyncResult);

// 2. 需要执行同步命令时，点击界面上的"确保同步执行"按钮
// 或者在代码中调用
if (connectionInstance.ensureSyncExecution()) {
    // 异步命令已停止，可以安全执行同步命令
    const result = connectionInstance.executeCommandJSON("setxChannelVoltage", [1, 1, 5.0, "O", 255]);
}
```

### 场景2: 界面操作管理

```javascript
// 用户在设备控制界面中的操作
function onExecuteButtonClick(commandName, channel) {
    // 界面会自动处理异步命令检测和管理
    executeCommand(commandName, channel);
}

// 用户点击"停止所有异步命令"按钮
function onStopAllAsyncClick() {
    stopAllAsyncCommands(); // 全局函数，已暴露到window对象
}

// 用户点击"确保同步执行"按钮
function onEnsureSyncClick() {
    ensureSyncExecution(); // 全局函数，已暴露到window对象
}
```

### 场景3: 程序化管理

```javascript
// 检查状态并进行相应处理
function checkAndManageAsyncCommands() {
    const status = connectionInstance.getAsyncStatus();
    
    if (status.has_running) {
        console.log(`发现 ${status.count} 个异步命令在运行:`, status.running_commands);
        
        // 根据需要停止特定命令
        status.running_commands.forEach(cmdName => {
            if (cmdName === 'getxChannelVoltageTms') {
                connectionInstance.stopAsyncCommand(cmdName);
            }
        });
    }
}
```

### 场景4: 错误恢复

```javascript
function robustCommandExecution(commandName, params, maxRetries = 3) {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
            // 确保可以安全执行
            connectionInstance.ensureSyncExecution();
            
            // 执行命令
            return connectionInstance.executeCommandJSON(commandName, params);
            
        } catch (error) {
            if (attempt < maxRetries - 1) {
                console.log(`命令执行失败 (尝试 ${attempt + 1}/${maxRetries}):`, error);
                // 短暂等待后重试
                setTimeout(() => {}, 100);
            } else {
                throw error;
            }
        }
    }
}
```

## 配置和自定义

### 1. 异步命令识别

在 `config.json` 中配置异步命令：

```json
{
  "commands": [
    {
      "name": "getxChannelVoltageTms",
      "timeout": -1,  // -1表示异步命令（持续监听）
      "asyncMode": true,  // 或者使用asyncMode标记
      // ... 其他配置
    }
  ]
}
```

### 2. 状态更新频率

```javascript
// 修改状态更新间隔（默认2秒）
function startAsyncStatusUpdate() {
    if (asyncThreadManager.statusUpdateTimer) {
        clearInterval(asyncThreadManager.statusUpdateTimer);
    }
    
    // 修改这里的间隔时间（毫秒）
    asyncThreadManager.statusUpdateTimer = setInterval(() => {
        refreshAsyncStatus();
    }, 1000); // 改为1秒更新一次
}
```

### 3. UI样式自定义

异步线程管理面板的样式可以通过CSS进行自定义：

```css
#async-thread-panel {
    background-color: #f8f9fa;
    border-bottom: 1px solid #dee2e6;
    /* 自定义样式 */
}

#async-status-display {
    font-weight: 600;
    /* 自定义状态显示样式 */
}
```

## 调试和测试

### 1. 使用测试脚本

```javascript
// 在浏览器控制台中运行
runAllTests(); // 执行所有测试

// 或者单独测试
testAsyncThreadManagement(); // 测试基础功能
testDllFunctionBinding();    // 测试DLL绑定
testUIComponents();          // 测试UI组件
```

### 2. 调试信息

启用详细的调试日志：

```javascript
// 在浏览器控制台中查看异步线程管理器状态
console.log('异步线程管理器状态:', asyncThreadManager);

// 查看当前运行的异步命令
console.log('运行中的异步命令:', Array.from(asyncThreadManager.runningCommands.keys()));

// 查看连接实例的异步管理方法
const connection = connectionInstances.values().next().value;
console.log('连接实例异步方法:', {
    stopAsyncCommand: typeof connection.stopAsyncCommand,
    getAsyncStatus: typeof connection.getAsyncStatus,
    // ... 其他方法
});
```

## 注意事项

1. **兼容性**：异步线程管理功能需要底层DLL支持，如果DLL不支持，会使用本地状态管理。

2. **性能**：状态更新定时器会定期查询异步状态，在资源受限的环境中可以调整更新频率。

3. **用户体验**：重复启动异步命令时会提示用户确认，确保用户了解当前状态。

4. **错误处理**：所有异步线程管理操作都有完善的错误处理机制，不会影响主要功能。

5. **资源清理**：关闭设备控制界面时会自动清理所有异步状态和定时器。

## 故障排除

### 问题1: 异步状态显示不更新
**解决方案**：
- 检查状态更新定时器是否正常启动
- 确认连接实例是否支持异步状态查询
- 查看浏览器控制台是否有错误信息

### 问题2: 停止异步命令无效
**解决方案**：
- 确认底层DLL是否支持停止异步命令功能
- 检查命令名称是否正确
- 尝试使用"停止所有异步命令"功能

### 问题3: UI面板不显示
**解决方案**：
- 确认设备控制界面是否正确初始化
- 检查`initializeAsyncThreadManager()`是否被调用
- 查看CSS样式是否正确应用

通过以上功能和指南，JavaScript异步线程管理功能可以有效解决异步命令和同步命令之间的冲突问题，提供更好的用户体验和系统稳定性。